
// https://developer.valvesoftware.com/wiki/VTF_(Valve_Texture_Format)

use std::{error::Error, io::{Read, Seek, SeekFrom}};
use crate::util::read_ext::ReadExt;
use bitflags::bitflags;
use image::{Rgba, RgbaImage};





bitflags! {
    #[derive(Debug)]
    pub struct TextureFlags: u32 {
        // Flags from the *.txt config file
        const POINTSAMPLE = 0x00000001;
        const TRILINEAR = 0x00000002;
        const CLAMPS = 0x00000004;
        const CLAMPT = 0x00000008;
        const ANISOTROPIC = 0x00000010;
        const HINT_DXT5 = 0x00000020;
        const PWL_CORRECTED = 0x00000040;
        const NORMAL = 0x00000080;
        const NOMIP = 0x00000100;
        const NOLOD = 0x00000200;
        const ALL_MIPS = 0x00000400;
        const PROCEDURAL = 0x00000800;

        // These are automatically generated by vtex from the texture data.
        const ONEBITALPHA = 0x00001000;
        const EIGHTBITALPHA = 0x00002000;

        // Newer flags from the *.txt config file
        const ENVMAP = 0x00004000;
        const RENDERTARGET = 0x00008000;
        const DEPTHRENDERTARGET = 0x00010000;
        const NODEBUGOVERRIDE = 0x00020000;
        const SINGLECOPY	= 0x00040000;
        const PRE_SRGB = 0x00080000;
        
        const UNUSED_00100000 = 0x00100000;
        const UNUSED_00200000 = 0x00200000;
        const UNUSED_00400000 = 0x00400000;

        const NODEPTHBUFFER = 0x00800000;

        const UNUSED_01000000 = 0x01000000;

        const CLAMPU = 0x02000000;
        const VERTEXTEXTURE = 0x04000000;
        const SSBUMP = 0x08000000;

        const UNUSED_10000000 = 0x10000000;

        const BORDER = 0x20000000;

        const UNUSED_40000000 = 0x40000000;
        const UNUSED_80000000 = 0x80000000;
    }
}





#[derive(Debug, Clone, Copy)]
#[allow(non_camel_case_types)]
pub enum TextureFormat {
    IMAGE_FORMAT_RGBA8888,
    IMAGE_FORMAT_ABGR8888,
    IMAGE_FORMAT_RGB888,
    IMAGE_FORMAT_BGR888,
    IMAGE_FORMAT_RGB565,
    IMAGE_FORMAT_I8,
    IMAGE_FORMAT_IA88,
    IMAGE_FORMAT_P8,
    IMAGE_FORMAT_A8,
    IMAGE_FORMAT_RGB888_BLUESCREEN,
    IMAGE_FORMAT_BGR888_BLUESCREEN,
    IMAGE_FORMAT_ARGB8888,
    IMAGE_FORMAT_BGRA8888,
    IMAGE_FORMAT_DXT1,
    IMAGE_FORMAT_DXT3,
    IMAGE_FORMAT_DXT5,
    IMAGE_FORMAT_BGRX8888,
    IMAGE_FORMAT_BGR565,
    IMAGE_FORMAT_BGRX5551,
    IMAGE_FORMAT_BGRA4444,
    IMAGE_FORMAT_DXT1_ONEBITALPHA,
    IMAGE_FORMAT_BGRA5551,
    IMAGE_FORMAT_UV88,
    IMAGE_FORMAT_UVWQ8888,
    IMAGE_FORMAT_RGBA16161616F,
    IMAGE_FORMAT_RGBA16161616,
    IMAGE_FORMAT_UVLX8888
}

impl TextureFormat {

    pub fn new(value: i32) -> Result<TextureFormat, Box<dyn Error>> {
        Ok(match value {
            -1 => panic!("Texture format NONE."),
            0 => TextureFormat::IMAGE_FORMAT_RGBA8888,
            1 => TextureFormat::IMAGE_FORMAT_ABGR8888,
            2 => TextureFormat::IMAGE_FORMAT_RGB888,
            3 => TextureFormat::IMAGE_FORMAT_BGR888,
            4 => TextureFormat::IMAGE_FORMAT_RGB565,
            5 => TextureFormat::IMAGE_FORMAT_I8,
            6 => TextureFormat::IMAGE_FORMAT_IA88,
            7 => TextureFormat::IMAGE_FORMAT_P8,
            8 => TextureFormat::IMAGE_FORMAT_A8,
            9 => TextureFormat::IMAGE_FORMAT_RGB888_BLUESCREEN,
            10 => TextureFormat::IMAGE_FORMAT_BGR888_BLUESCREEN,
            11 => TextureFormat::IMAGE_FORMAT_ARGB8888,
            12 => TextureFormat::IMAGE_FORMAT_BGRA8888,
            13 => TextureFormat::IMAGE_FORMAT_DXT1,
            14 => TextureFormat::IMAGE_FORMAT_DXT3,
            15 => TextureFormat::IMAGE_FORMAT_DXT5,
            16 => TextureFormat::IMAGE_FORMAT_BGRX8888,
            17 => TextureFormat::IMAGE_FORMAT_BGR565,
            18 => TextureFormat::IMAGE_FORMAT_BGRX5551,
            19 => TextureFormat::IMAGE_FORMAT_BGRA4444,
            20 => TextureFormat::IMAGE_FORMAT_DXT1_ONEBITALPHA,
            21 => TextureFormat::IMAGE_FORMAT_BGRA5551,
            22 => TextureFormat::IMAGE_FORMAT_UV88,
            23 => TextureFormat::IMAGE_FORMAT_UVWQ8888,
            24 => TextureFormat::IMAGE_FORMAT_RGBA16161616F,
            25 => TextureFormat::IMAGE_FORMAT_RGBA16161616,
            26 => TextureFormat::IMAGE_FORMAT_UVLX8888,
            _ => panic!("Unknown texture format."),
        })
    }

    pub fn byte_size(&self, width: u32, height: u32) -> u32 {
        match self {
            TextureFormat::IMAGE_FORMAT_RGBA16161616F |
            TextureFormat::IMAGE_FORMAT_RGBA16161616 
                => width * height * 8,
            TextureFormat::IMAGE_FORMAT_RGBA8888 |
            TextureFormat::IMAGE_FORMAT_ABGR8888 |
            TextureFormat::IMAGE_FORMAT_ARGB8888 |
            TextureFormat::IMAGE_FORMAT_BGRA8888 |
            TextureFormat::IMAGE_FORMAT_BGRX8888 |
            TextureFormat::IMAGE_FORMAT_UVWQ8888 |
            TextureFormat::IMAGE_FORMAT_UVLX8888
                => width * height * 4,
            TextureFormat::IMAGE_FORMAT_RGB888 |
            TextureFormat::IMAGE_FORMAT_BGR888 |
            TextureFormat::IMAGE_FORMAT_RGB888_BLUESCREEN |
            TextureFormat::IMAGE_FORMAT_BGR888_BLUESCREEN
                => width * height * 3,
            TextureFormat::IMAGE_FORMAT_RGB565 |
            TextureFormat::IMAGE_FORMAT_IA88 |
            TextureFormat::IMAGE_FORMAT_BGR565 |
            TextureFormat::IMAGE_FORMAT_BGRX5551 |
            TextureFormat::IMAGE_FORMAT_BGRA4444 |
            TextureFormat::IMAGE_FORMAT_BGRA5551 |
            TextureFormat::IMAGE_FORMAT_UV88
                => width * height * 2,
            TextureFormat::IMAGE_FORMAT_I8 |
            TextureFormat::IMAGE_FORMAT_P8 |
            TextureFormat::IMAGE_FORMAT_A8
                => width * height,
            TextureFormat::IMAGE_FORMAT_DXT1 |
            TextureFormat::IMAGE_FORMAT_DXT1_ONEBITALPHA |
            TextureFormat::IMAGE_FORMAT_DXT3 |
            TextureFormat::IMAGE_FORMAT_DXT5
                => {
                    // Texture is encoded into 4x4 blocks, size must be multiple of 4.
                    let width = width + (width % 4);
                    let height = height + (height % 4);
                    match self {
                        TextureFormat::IMAGE_FORMAT_DXT1 |
                        TextureFormat::IMAGE_FORMAT_DXT1_ONEBITALPHA
                            => (width * height) / 2,
                        TextureFormat::IMAGE_FORMAT_DXT3 |
                        TextureFormat::IMAGE_FORMAT_DXT5
                            => width * height,
                        _ => panic!("Error"),
                    }
                },
        }
    }

}





#[derive(Debug)]
pub struct Texture {
    width: u32,
    height: u32,
    format: TextureFormat,
    data: Vec<u8>,
}

impl Texture {

    pub fn new(width: u32, height: u32, format: TextureFormat, data: Vec<u8>) -> Self {
        if (data.len() as u32) != format.byte_size(width, height) {
            println!("VTF TEXTURE SIZE DOES NOT MATCH.");
        }
        Self { width, height, format, data }
    }

    fn convert_pixels<F>(&self, image: &mut RgbaImage, pixel_bytes: usize, mut convert: F)
    where
        F: FnMut(&Vec<u8>) -> Rgba<u8>
    {
        let mut offset: usize = 0;
        let mut bytes: Vec<u8> = Vec::new();

        for y in 0..image.height() {
            for x in 0..image.width() {
                bytes.resize(pixel_bytes, 0);
                if offset + pixel_bytes > self.data.len() {
                    panic!("Convert pixels out of bounds.");
                }
                bytes.clone_from_slice(&self.data[offset..(offset + pixel_bytes)]);
                offset += pixel_bytes;

                let color = convert(&bytes);
                image.put_pixel(x, y, color);
            }
        }
    }

    pub fn to_image(&self) -> RgbaImage {
        let mut image = RgbaImage::new(self.width, self.height);

        match self.format {
            TextureFormat::IMAGE_FORMAT_RGBA8888 => self.convert_pixels(&mut image, 4, |pixel| {
                Rgba([pixel[0], pixel[1], pixel[2], pixel[3]])
            }),
            format => panic!("Cannot convert image format. {:?}", format),
        }
        image
    }

}





#[derive(Debug, Clone, Copy)]
struct VTFVersion {
    major: u32,
    minor: u32,
}

impl VTFVersion {
    pub fn new(major: u32, minor: u32) -> Self {
        Self { major, minor }
    }
}

impl PartialEq for VTFVersion {
    fn eq(&self, other: &Self) -> bool {
        self.major == other.major && self.minor == other.minor
    }
}

impl PartialOrd for VTFVersion {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        match self.major.partial_cmp(&other.major) {
            Some(core::cmp::Ordering::Equal) => {}
            ord => return ord,
        }
        self.minor.partial_cmp(&other.minor)
    }
}





#[derive(Debug)]
pub struct VTF {
    lowres_texture: Option<Texture>,
    mipmaps: u8,
    frames: u16,
    first_frame: u16,
    faces: u8,
    depth: u16,
    textures: Vec<Texture>,
}

impl VTF {

    pub fn load(mut data: impl Read + Seek) -> Result<Self, Box<dyn Error>> {
        assert!(data.check_magic_string("VTF\0")?);

        let version = VTFVersion::new(data.read_primitive()?, data.read_primitive()?);

        let header_size: u32 = data.read_primitive()?;

        let width: u16 = data.read_primitive()?;
        let height: u16 = data.read_primitive()?;

        let flags = TextureFlags::from_bits_retain(data.read_primitive()?);

        let frames: u16 = data.read_primitive()?;
        let mut first_frame: u16 = data.read_primitive()?;

        data.seek(SeekFrom::Current(4))?;
        let reflectivity: (f32, f32, f32) = (data.read_primitive()?, data.read_primitive()?, data.read_primitive()?);
        data.seek(SeekFrom::Current(4))?;

        let bumpmap_scale: f32 = data.read_primitive()?;

        let highres_format = TextureFormat::new(data.read_primitive()?)?;

        let mipmaps: u8 = data.read_primitive()?;
        let faces = if flags.intersects(TextureFlags::ENVMAP) {
            if version < VTFVersion::new(7, 5) && first_frame == 0xFFFF {
                first_frame = 0;
                7
            } else {
                6
            }
        } else {
            1
        };

        let lowres_format = TextureFormat::new(data.read_primitive()?)?;
        let lowres_width: u8 = data.read_primitive()?;
        let lowres_height: u8 = data.read_primitive()?;

        let mut depth: u16 = 1;

        if version >= VTFVersion::new(7, 2) {
            depth = data.read_primitive()?;
        }

        if version >= VTFVersion::new(7, 3) {
            panic!("Unsupported VTF version. {:?}", version);
        }

        // Read texture data
        data.seek(SeekFrom::Start(header_size as u64))?;

        // Low res texture
        let lowres_texture = {
            let size = lowres_format.byte_size(lowres_width as u32, lowres_height as u32);
            if size > 0 {
                let tex_data = data.read_to_vec(size as usize)?;
                Some(Texture::new(lowres_width as u32, lowres_height as u32, lowres_format, tex_data))
            } else {
                None
            }
        };

        // High res texture
        let mut textures = Vec::new();
        for mipmap in 0..mipmaps {
            for frame in 0..frames {
                for face in 0..faces {
                    for slice in 0..depth {
                        let inverse_mip = mipmaps - mipmap - 1;
                        let mip_width = width >> inverse_mip;
                        let mip_height = height >> inverse_mip;
                        let size = highres_format.byte_size(mip_width as u32, mip_height as u32);
                        let tex_data = data.read_to_vec(size as usize)?;
                        let texture = Texture::new(mip_width as u32, mip_height as u32, highres_format, tex_data);
                        textures.push(texture);
                    }
                }
            }
        }

        Ok(Self {
            lowres_texture,
            mipmaps,
            frames,
            first_frame,
            faces,
            depth,
            textures
        })
    }



    pub fn mipmaps(&self) -> u8 { self.mipmaps }
    pub fn frames(&self) -> u16 { self.frames }
    pub fn faces(&self) -> u8 { self.faces }
    pub fn depth(&self) -> u16 { self.depth }

    fn texture_index(&self, mipmap: u8, frame: u16, face: u8, slice: u16) -> Option<usize> {
        if mipmap >= self.mipmaps || frame >= self.frames || face >= self.faces || slice >= self.depth {
            return None;
        }

        let mipmaps = self.mipmaps as usize;
        let frames = self.frames as usize;
        let faces = self.faces as usize;
        let depth = self.depth as usize;

        let mipmap = (self.mipmaps - mipmap - 1) as usize;
        let frame = frame as usize;
        let face = face as usize;
        let slice = slice as usize;

        Some(
            mipmap +
            frame * mipmaps +
            face * frames * mipmaps +
            slice * faces * frames * mipmaps
        )
    }
    pub fn texture(&self, mipmap: u8, frame: u16, face: u8, slice: u16) -> Option<&Texture> {
        if let Some(index) = self.texture_index(mipmap, frame, face, slice) {
            self.textures.get(index)
        } else {
            None
        }
    }

}


